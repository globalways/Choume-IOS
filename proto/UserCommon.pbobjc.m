// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.common.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "UserCommon.pbobjc.h"
#import "Common.pbobjc.h"
#import "UserWalletCommon.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma mark - UserCommonRoot

@implementation UserCommonRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[CommonRoot extensionRegistry]];
    [registry addExtensions:[UserWalletCommonRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - UserCommonRoot_FileDescriptor

static GPBFileDescriptor *UserCommonRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"proto"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum UserSex

GPBEnumDescriptor *UserSex_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "UnknownSex", .number = UserSex_UnknownSex },
      { .name = "Male", .number = UserSex_Male },
      { .name = "Famale", .number = UserSex_Famale },
      { .name = "Shemail", .number = UserSex_Shemail },
    };
    static const char *extraTextFormatInfo = "\001\000g\203\000";
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserSex)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:UserSex_IsValidValue
                                      extraTextFormatInfo:extraTextFormatInfo];
  }
  return descriptor;
}

BOOL UserSex_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserSex_UnknownSex:
    case UserSex_Male:
    case UserSex_Famale:
    case UserSex_Shemail:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum UserStatus

GPBEnumDescriptor *UserStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "Invalid", .number = UserStatus_Invalid },
      { .name = "Notuse", .number = UserStatus_Notuse },
      { .name = "Pending", .number = UserStatus_Pending },
      { .name = "Use", .number = UserStatus_Use },
      { .name = "Lock", .number = UserStatus_Lock },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserStatus)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:UserStatus_IsValidValue];
  }
  return descriptor;
}

BOOL UserStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserStatus_Invalid:
    case UserStatus_Notuse:
    case UserStatus_Pending:
    case UserStatus_Use:
    case UserStatus_Lock:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum UserAuthority

GPBEnumDescriptor *UserAuthority_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "User", .number = UserAuthority_User },
      { .name = "Admin", .number = UserAuthority_Admin },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserAuthority)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:UserAuthority_IsValidValue];
  }
  return descriptor;
}

BOOL UserAuthority_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserAuthority_User:
    case UserAuthority_Admin:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TokenItem

@implementation TokenItem

@dynamic appId;
@dynamic hongId;
@dynamic loggedTime;
@dynamic expiredTime;

typedef struct TokenItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *appId;
  uint64_t hongId;
  int64_t loggedTime;
  int64_t expiredTime;
} TokenItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appId",
        .number = TokenItem_FieldNumber_AppId,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(TokenItem__storage_, appId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "hongId",
        .number = TokenItem_FieldNumber_HongId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(TokenItem__storage_, hongId),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "loggedTime",
        .number = TokenItem_FieldNumber_LoggedTime,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(TokenItem__storage_, loggedTime),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "expiredTime",
        .number = TokenItem_FieldNumber_ExpiredTime,
        .hasIndex = 3,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(TokenItem__storage_, expiredTime),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\004\001\005\000\002\006\000\003\n\000\004\013\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TokenItem class]
                                     rootClass:[UserCommonRoot class]
                                          file:UserCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(TokenItem__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LoginParam

@implementation LoginParam

@dynamic appId;
@dynamic username;
@dynamic password;
@dynamic token;

typedef struct LoginParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *appId;
  NSString *username;
  NSString *password;
  NSString *token;
} LoginParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appId",
        .number = LoginParam_FieldNumber_AppId,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(LoginParam__storage_, appId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "username",
        .number = LoginParam_FieldNumber_Username,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(LoginParam__storage_, username),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "password",
        .number = LoginParam_FieldNumber_Password,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(LoginParam__storage_, password),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "token",
        .number = LoginParam_FieldNumber_Token,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(LoginParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\001\005\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginParam class]
                                     rootClass:[UserCommonRoot class]
                                          file:UserCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(LoginParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LoginResp

@implementation LoginResp

@dynamic hasResp, resp;
@dynamic hasUser, user;
@dynamic token;

typedef struct LoginResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  User *user;
  NSString *token;
} LoginResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = LoginResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(LoginResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "user",
        .number = LoginResp_FieldNumber_User,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(LoginResp__storage_, user),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .fieldOptions = NULL,
      },
      {
        .name = "token",
        .number = LoginResp_FieldNumber_Token,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(LoginResp__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginResp class]
                                     rootClass:[UserCommonRoot class]
                                          file:UserCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(LoginResp__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RegisterAppUserParam

@implementation RegisterAppUserParam

@dynamic nick;
@dynamic tel;
@dynamic password;

typedef struct RegisterAppUserParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *nick;
  NSString *tel;
  NSString *password;
} RegisterAppUserParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nick",
        .number = RegisterAppUserParam_FieldNumber_Nick,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(RegisterAppUserParam__storage_, nick),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "tel",
        .number = RegisterAppUserParam_FieldNumber_Tel,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(RegisterAppUserParam__storage_, tel),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "password",
        .number = RegisterAppUserParam_FieldNumber_Password,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(RegisterAppUserParam__storage_, password),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterAppUserParam class]
                                     rootClass:[UserCommonRoot class]
                                          file:UserCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(RegisterAppUserParam__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LoginAppParam

@implementation LoginAppParam

@dynamic username;
@dynamic password;
@dynamic token;

typedef struct LoginAppParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *username;
  NSString *password;
  NSString *token;
} LoginAppParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .number = LoginAppParam_FieldNumber_Username,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(LoginAppParam__storage_, username),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "password",
        .number = LoginAppParam_FieldNumber_Password,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(LoginAppParam__storage_, password),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "token",
        .number = LoginAppParam_FieldNumber_Token,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(LoginAppParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginAppParam class]
                                     rootClass:[UserCommonRoot class]
                                          file:UserCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(LoginAppParam__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LogoutParam

@implementation LogoutParam

@dynamic token;

typedef struct LogoutParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} LogoutParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = LogoutParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(LogoutParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LogoutParam class]
                                     rootClass:[UserCommonRoot class]
                                          file:UserCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(LogoutParam__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAppUserParam

@implementation GetAppUserParam

@dynamic hongId;

typedef struct GetAppUserParam__storage_ {
  uint32_t _has_storage_[1];
  uint64_t hongId;
} GetAppUserParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hongId",
        .number = GetAppUserParam_FieldNumber_HongId,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(GetAppUserParam__storage_, hongId),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\001\006\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAppUserParam class]
                                     rootClass:[UserCommonRoot class]
                                          file:UserCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(GetAppUserParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - User

@implementation User

@dynamic id_p;
@dynamic hongId;
@dynamic nick;
@dynamic tel;
@dynamic email;
@dynamic password;
@dynamic avatar;
@dynamic age;
@dynamic sex;
@dynamic authority;
@dynamic status;
@dynamic regTime;
@dynamic genTime;
@dynamic comment;
@dynamic auditor;
@dynamic addrsArray, addrsArray_Count;
@dynamic hasWallet, wallet;

typedef struct User__storage_ {
  uint32_t _has_storage_[1];
  uint32_t age;
  UserSex sex;
  UserAuthority authority;
  UserStatus status;
  NSString *nick;
  NSString *tel;
  NSString *email;
  NSString *password;
  NSString *avatar;
  NSString *comment;
  NSMutableArray *addrsArray;
  UserWallet *wallet;
  int64_t id_p;
  uint64_t hongId;
  int64_t regTime;
  int64_t genTime;
  uint64_t auditor;
} User__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .number = User_FieldNumber_Id_p,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(User__storage_, id_p),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "hongId",
        .number = User_FieldNumber_HongId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(User__storage_, hongId),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "nick",
        .number = User_FieldNumber_Nick,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(User__storage_, nick),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "tel",
        .number = User_FieldNumber_Tel,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(User__storage_, tel),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "email",
        .number = User_FieldNumber_Email,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(User__storage_, email),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "password",
        .number = User_FieldNumber_Password,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(User__storage_, password),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "avatar",
        .number = User_FieldNumber_Avatar,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(User__storage_, avatar),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "age",
        .number = User_FieldNumber_Age,
        .hasIndex = 7,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
        .offset = offsetof(User__storage_, age),
        .defaultValue.valueUInt32 = 0U,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "sex",
        .number = User_FieldNumber_Sex,
        .hasIndex = 8,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(User__storage_, sex),
        .defaultValue.valueEnum = UserSex_UnknownSex,
        .dataTypeSpecific.enumDescFunc = UserSex_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "authority",
        .number = User_FieldNumber_Authority,
        .hasIndex = 9,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(User__storage_, authority),
        .defaultValue.valueEnum = UserAuthority_User,
        .dataTypeSpecific.enumDescFunc = UserAuthority_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "status",
        .number = User_FieldNumber_Status,
        .hasIndex = 10,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(User__storage_, status),
        .defaultValue.valueEnum = UserStatus_Invalid,
        .dataTypeSpecific.enumDescFunc = UserStatus_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "regTime",
        .number = User_FieldNumber_RegTime,
        .hasIndex = 11,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(User__storage_, regTime),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "genTime",
        .number = User_FieldNumber_GenTime,
        .hasIndex = 12,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(User__storage_, genTime),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "comment",
        .number = User_FieldNumber_Comment,
        .hasIndex = 13,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(User__storage_, comment),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "auditor",
        .number = User_FieldNumber_Auditor,
        .hasIndex = 14,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(User__storage_, auditor),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "addrsArray",
        .number = User_FieldNumber_AddrsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(User__storage_, addrsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(UserAddress),
        .fieldOptions = NULL,
      },
      {
        .name = "wallet",
        .number = User_FieldNumber_Wallet,
        .hasIndex = 16,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(User__storage_, wallet),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(UserWallet),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\003\002\006\000\014\007\000\r\007\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[User class]
                                     rootClass:[UserCommonRoot class]
                                          file:UserCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(User__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t User_Sex_RawValue(User *message) {
  GPBDescriptor *descriptor = [User descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:User_FieldNumber_Sex];
  return GPBGetMessageInt32Field(message, field);
}

void SetUser_Sex_RawValue(User *message, int32_t value) {
  GPBDescriptor *descriptor = [User descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:User_FieldNumber_Sex];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t User_Authority_RawValue(User *message) {
  GPBDescriptor *descriptor = [User descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:User_FieldNumber_Authority];
  return GPBGetMessageInt32Field(message, field);
}

void SetUser_Authority_RawValue(User *message, int32_t value) {
  GPBDescriptor *descriptor = [User descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:User_FieldNumber_Authority];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t User_Status_RawValue(User *message) {
  GPBDescriptor *descriptor = [User descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:User_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetUser_Status_RawValue(User *message, int32_t value) {
  GPBDescriptor *descriptor = [User descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:User_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UserAddress

@implementation UserAddress

@dynamic id_p;
@dynamic name;
@dynamic contact;
@dynamic area;
@dynamic detail;
@dynamic userId;

typedef struct UserAddress__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *contact;
  NSString *area;
  NSString *detail;
  int64_t id_p;
  uint64_t userId;
} UserAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .number = UserAddress_FieldNumber_Id_p,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(UserAddress__storage_, id_p),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "name",
        .number = UserAddress_FieldNumber_Name,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(UserAddress__storage_, name),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "contact",
        .number = UserAddress_FieldNumber_Contact,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(UserAddress__storage_, contact),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "area",
        .number = UserAddress_FieldNumber_Area,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(UserAddress__storage_, area),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "detail",
        .number = UserAddress_FieldNumber_Detail,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(UserAddress__storage_, detail),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userId",
        .number = UserAddress_FieldNumber_UserId,
        .hasIndex = 5,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(UserAddress__storage_, userId),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\006\006\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserAddress class]
                                     rootClass:[UserCommonRoot class]
                                          file:UserCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(UserAddress__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


// @@protoc_insertion_point(global_scope)

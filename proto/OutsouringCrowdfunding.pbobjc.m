// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: outsouring.crowdfunding.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "OutsouringCrowdfunding.pbobjc.h"
#import "Common.pbobjc.h"
#import "UserCommon.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma mark - OutsouringCrowdfundingRoot

@implementation OutsouringCrowdfundingRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPBDebugCheckRuntimeVersion();
    registry = [[GPBExtensionRegistry alloc] init];
    [registry addExtensions:[CommonRoot extensionRegistry]];
    [registry addExtensions:[UserCommonRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - OutsouringCrowdfundingRoot_FileDescriptor

static GPBFileDescriptor *OutsouringCrowdfundingRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"proto"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum CrowdFundingCategory

GPBEnumDescriptor *CrowdFundingCategory_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "InvalidCfc", .number = CrowdFundingCategory_InvalidCfc },
      { .name = "HappyCfc", .number = CrowdFundingCategory_HappyCfc },
      { .name = "MoneyCfc", .number = CrowdFundingCategory_MoneyCfc },
      { .name = "LoveCfc", .number = CrowdFundingCategory_LoveCfc },
      { .name = "ProjectCfc", .number = CrowdFundingCategory_ProjectCfc },
      { .name = "ProductCfc", .number = CrowdFundingCategory_ProductCfc },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CrowdFundingCategory)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:CrowdFundingCategory_IsValidValue];
  }
  return descriptor;
}

BOOL CrowdFundingCategory_IsValidValue(int32_t value__) {
  switch (value__) {
    case CrowdFundingCategory_InvalidCfc:
    case CrowdFundingCategory_HappyCfc:
    case CrowdFundingCategory_MoneyCfc:
    case CrowdFundingCategory_LoveCfc:
    case CrowdFundingCategory_ProjectCfc:
    case CrowdFundingCategory_ProductCfc:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CfProjectTag

GPBEnumDescriptor *CfProjectTag_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "InvalidCfpt", .number = CfProjectTag_InvalidCfpt },
      { .name = "LimitTimeCfpt", .number = CfProjectTag_LimitTimeCfpt },
      { .name = "QuestionCfpt", .number = CfProjectTag_QuestionCfpt },
      { .name = "HotCfpt", .number = CfProjectTag_HotCfpt },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CfProjectTag)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:CfProjectTag_IsValidValue];
  }
  return descriptor;
}

BOOL CfProjectTag_IsValidValue(int32_t value__) {
  switch (value__) {
    case CfProjectTag_InvalidCfpt:
    case CfProjectTag_LimitTimeCfpt:
    case CfProjectTag_QuestionCfpt:
    case CfProjectTag_HotCfpt:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CfProjectStatus

GPBEnumDescriptor *CfProjectStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "InvalidCfps", .number = CfProjectStatus_InvalidCfps },
      { .name = "AuditingCfps", .number = CfProjectStatus_AuditingCfps },
      { .name = "PublishedCfps", .number = CfProjectStatus_PublishedCfps },
      { .name = "FinishCfps", .number = CfProjectStatus_FinishCfps },
      { .name = "FailureCfps", .number = CfProjectStatus_FailureCfps },
      { .name = "CompletedCfps", .number = CfProjectStatus_CompletedCfps },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CfProjectStatus)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:CfProjectStatus_IsValidValue];
  }
  return descriptor;
}

BOOL CfProjectStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case CfProjectStatus_InvalidCfps:
    case CfProjectStatus_AuditingCfps:
    case CfProjectStatus_PublishedCfps:
    case CfProjectStatus_FinishCfps:
    case CfProjectStatus_FailureCfps:
    case CfProjectStatus_CompletedCfps:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CfProjectSupportType

GPBEnumDescriptor *CfProjectSupportType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "InvalidCfpst", .number = CfProjectSupportType_InvalidCfpst },
      { .name = "MoneyCfpst", .number = CfProjectSupportType_MoneyCfpst },
      { .name = "PeopleCfpst", .number = CfProjectSupportType_PeopleCfpst },
      { .name = "GoodsCfpst", .number = CfProjectSupportType_GoodsCfpst },
      { .name = "EquityCfpst", .number = CfProjectSupportType_EquityCfpst },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CfProjectSupportType)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:CfProjectSupportType_IsValidValue];
  }
  return descriptor;
}

BOOL CfProjectSupportType_IsValidValue(int32_t value__) {
  switch (value__) {
    case CfProjectSupportType_InvalidCfpst:
    case CfProjectSupportType_MoneyCfpst:
    case CfProjectSupportType_PeopleCfpst:
    case CfProjectSupportType_GoodsCfpst:
    case CfProjectSupportType_EquityCfpst:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CfUserCertificationType

GPBEnumDescriptor *CfUserCertificationType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "InvalidCfuct", .number = CfUserCertificationType_InvalidCfuct },
      { .name = "StudentCfuct", .number = CfUserCertificationType_StudentCfuct },
      { .name = "AgencyCfuct", .number = CfUserCertificationType_AgencyCfuct },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CfUserCertificationType)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:CfUserCertificationType_IsValidValue];
  }
  return descriptor;
}

BOOL CfUserCertificationType_IsValidValue(int32_t value__) {
  switch (value__) {
    case CfUserCertificationType_InvalidCfuct:
    case CfUserCertificationType_StudentCfuct:
    case CfUserCertificationType_AgencyCfuct:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CfUserCeritificationStatus

GPBEnumDescriptor *CfUserCeritificationStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "InvalidCfucs", .number = CfUserCeritificationStatus_InvalidCfucs },
      { .name = "ApplyingCfucs", .number = CfUserCeritificationStatus_ApplyingCfucs },
      { .name = "SuccessCfucs", .number = CfUserCeritificationStatus_SuccessCfucs },
      { .name = "FailureCfucs", .number = CfUserCeritificationStatus_FailureCfucs },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CfUserCeritificationStatus)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:CfUserCeritificationStatus_IsValidValue];
  }
  return descriptor;
}

BOOL CfUserCeritificationStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case CfUserCeritificationStatus_InvalidCfucs:
    case CfUserCeritificationStatus_ApplyingCfucs:
    case CfUserCeritificationStatus_SuccessCfucs:
    case CfUserCeritificationStatus_FailureCfucs:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CfProjectInvestStatus

GPBEnumDescriptor *CfProjectInvestStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "InvalidCfpis", .number = CfProjectInvestStatus_InvalidCfpis },
      { .name = "PendingCfpis", .number = CfProjectInvestStatus_PendingCfpis },
      { .name = "PaidCfpis", .number = CfProjectInvestStatus_PaidCfpis },
      { .name = "SuccessCfpis", .number = CfProjectInvestStatus_SuccessCfpis },
      { .name = "ExpiredCfpis", .number = CfProjectInvestStatus_ExpiredCfpis },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CfProjectInvestStatus)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:CfProjectInvestStatus_IsValidValue];
  }
  return descriptor;
}

BOOL CfProjectInvestStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case CfProjectInvestStatus_InvalidCfpis:
    case CfProjectInvestStatus_PendingCfpis:
    case CfProjectInvestStatus_PaidCfpis:
    case CfProjectInvestStatus_SuccessCfpis:
    case CfProjectInvestStatus_ExpiredCfpis:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CFCBHistoryType

GPBEnumDescriptor *CFCBHistoryType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "InvaildCb", .number = CFCBHistoryType_InvaildCb },
      { .name = "ExchangeCb", .number = CFCBHistoryType_ExchangeCb },
      { .name = "ConsumeCb", .number = CFCBHistoryType_ConsumeCb },
      { .name = "WithdrawCb", .number = CFCBHistoryType_WithdrawCb },
      { .name = "TurnbackCb", .number = CFCBHistoryType_TurnbackCb },
      { .name = "GiveCb", .number = CFCBHistoryType_GiveCb },
      { .name = "ChouCb", .number = CFCBHistoryType_ChouCb },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CFCBHistoryType)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:CFCBHistoryType_IsValidValue];
  }
  return descriptor;
}

BOOL CFCBHistoryType_IsValidValue(int32_t value__) {
  switch (value__) {
    case CFCBHistoryType_InvaildCb:
    case CFCBHistoryType_ExchangeCb:
    case CFCBHistoryType_ConsumeCb:
    case CFCBHistoryType_WithdrawCb:
    case CFCBHistoryType_TurnbackCb:
    case CFCBHistoryType_GiveCb:
    case CFCBHistoryType_ChouCb:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CfUserRole

GPBEnumDescriptor *CfUserRole_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "InvalidCfur", .number = CfUserRole_InvalidCfur },
      { .name = "UserCfur", .number = CfUserRole_UserCfur },
      { .name = "AdminCfur", .number = CfUserRole_AdminCfur },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CfUserRole)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:CfUserRole_IsValidValue];
  }
  return descriptor;
}

BOOL CfUserRole_IsValidValue(int32_t value__) {
  switch (value__) {
    case CfUserRole_InvalidCfur:
    case CfUserRole_UserCfur:
    case CfUserRole_AdminCfur:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CfMessageType

GPBEnumDescriptor *CfMessageType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static GPBMessageEnumValueDescription values[] = {
      { .name = "InvalidCfmt", .number = CfMessageType_InvalidCfmt },
      { .name = "SysCfmt", .number = CfMessageType_SysCfmt },
      { .name = "ProjectCfmt", .number = CfMessageType_ProjectCfmt },
      { .name = "CommentCfmt", .number = CfMessageType_CommentCfmt },
    };
    descriptor = [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CfMessageType)
                                                   values:values
                                               valueCount:sizeof(values) / sizeof(GPBMessageEnumValueDescription)
                                             enumVerifier:CfMessageType_IsValidValue];
  }
  return descriptor;
}

BOOL CfMessageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case CfMessageType_InvalidCfmt:
    case CfMessageType_SysCfmt:
    case CfMessageType_ProjectCfmt:
    case CfMessageType_CommentCfmt:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GetCFUserResp

@implementation GetCFUserResp

@dynamic hasResp, resp;
@dynamic hasCfUser, cfUser;

typedef struct GetCFUserResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  CfUser *cfUser;
} GetCFUserResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = GetCFUserResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(GetCFUserResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "cfUser",
        .number = GetCFUserResp_FieldNumber_CfUser,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(GetCFUserResp__storage_, cfUser),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfUser),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\006\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetCFUserResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(GetCFUserResp__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PassCfProjectInvestParam

@implementation PassCfProjectInvestParam

@dynamic token;
@dynamic investId;

typedef struct PassCfProjectInvestParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  int64_t investId;
} PassCfProjectInvestParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = PassCfProjectInvestParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(PassCfProjectInvestParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "investId",
        .number = PassCfProjectInvestParam_FieldNumber_InvestId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(PassCfProjectInvestParam__storage_, investId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\010\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PassCfProjectInvestParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(PassCfProjectInvestParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RejectCfProjectInvestParam

@implementation RejectCfProjectInvestParam

@dynamic token;
@dynamic investId;

typedef struct RejectCfProjectInvestParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  int64_t investId;
} RejectCfProjectInvestParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = RejectCfProjectInvestParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(RejectCfProjectInvestParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "investId",
        .number = RejectCfProjectInvestParam_FieldNumber_InvestId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(RejectCfProjectInvestParam__storage_, investId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\010\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RejectCfProjectInvestParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(RejectCfProjectInvestParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CfUserHistoriesParam

@implementation CfUserHistoriesParam

@dynamic token;
@dynamic type;
@dynamic startTime;
@dynamic endTime;

typedef struct CfUserHistoriesParam__storage_ {
  uint32_t _has_storage_[1];
  CFCBHistoryType type;
  NSString *token;
  int64_t startTime;
  int64_t endTime;
} CfUserHistoriesParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = CfUserHistoriesParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfUserHistoriesParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "type",
        .number = CfUserHistoriesParam_FieldNumber_Type,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CfUserHistoriesParam__storage_, type),
        .defaultValue.valueEnum = CFCBHistoryType_InvaildCb,
        .dataTypeSpecific.enumDescFunc = CFCBHistoryType_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "startTime",
        .number = CfUserHistoriesParam_FieldNumber_StartTime,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfUserHistoriesParam__storage_, startTime),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "endTime",
        .number = CfUserHistoriesParam_FieldNumber_EndTime,
        .hasIndex = 3,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfUserHistoriesParam__storage_, endTime),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\003\t\000\004\007\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfUserHistoriesParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfUserHistoriesParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CfUserHistoriesParam_Type_RawValue(CfUserHistoriesParam *message) {
  GPBDescriptor *descriptor = [CfUserHistoriesParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfUserHistoriesParam_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetCfUserHistoriesParam_Type_RawValue(CfUserHistoriesParam *message, int32_t value) {
  GPBDescriptor *descriptor = [CfUserHistoriesParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfUserHistoriesParam_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CfUserHistoriesResp

@implementation CfUserHistoriesResp

@dynamic hasResp, resp;
@dynamic historiesArray, historiesArray_Count;

typedef struct CfUserHistoriesResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  NSMutableArray *historiesArray;
} CfUserHistoriesResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = CfUserHistoriesResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfUserHistoriesResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "historiesArray",
        .number = CfUserHistoriesResp_FieldNumber_HistoriesArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfUserHistoriesResp__storage_, historiesArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CFCBHistory),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfUserHistoriesResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfUserHistoriesResp__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CfUserWithdrawParam

@implementation CfUserWithdrawParam

@dynamic token;
@dynamic coin;
@dynamic thirdPartyWalletId;

typedef struct CfUserWithdrawParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  uint64_t coin;
  int64_t thirdPartyWalletId;
} CfUserWithdrawParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = CfUserWithdrawParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfUserWithdrawParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "coin",
        .number = CfUserWithdrawParam_FieldNumber_Coin,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfUserWithdrawParam__storage_, coin),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "thirdPartyWalletId",
        .number = CfUserWithdrawParam_FieldNumber_ThirdPartyWalletId,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfUserWithdrawParam__storage_, thirdPartyWalletId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\003\022\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfUserWithdrawParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfUserWithdrawParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CfUserWithdrawResp

@implementation CfUserWithdrawResp

@dynamic hasResp, resp;
@dynamic hasHistory, history;

typedef struct CfUserWithdrawResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  CFCBHistory *history;
} CfUserWithdrawResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = CfUserWithdrawResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfUserWithdrawResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "history",
        .number = CfUserWithdrawResp_FieldNumber_History,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfUserWithdrawResp__storage_, history),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CFCBHistory),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfUserWithdrawResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfUserWithdrawResp__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CfUserCBExchangeParam

@implementation CfUserCBExchangeParam

@dynamic token;
@dynamic rmb;
@dynamic password;

typedef struct CfUserCBExchangeParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  NSString *password;
  uint64_t rmb;
} CfUserCBExchangeParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = CfUserCBExchangeParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfUserCBExchangeParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "rmb",
        .number = CfUserCBExchangeParam_FieldNumber_Rmb,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfUserCBExchangeParam__storage_, rmb),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "password",
        .number = CfUserCBExchangeParam_FieldNumber_Password,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfUserCBExchangeParam__storage_, password),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfUserCBExchangeParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfUserCBExchangeParam__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CfUserCBExchangeResp

@implementation CfUserCBExchangeResp

@dynamic hasResp, resp;
@dynamic hasHistory, history;

typedef struct CfUserCBExchangeResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  CFCBHistory *history;
} CfUserCBExchangeResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = CfUserCBExchangeResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfUserCBExchangeResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "history",
        .number = CfUserCBExchangeResp_FieldNumber_History,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfUserCBExchangeResp__storage_, history),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CFCBHistory),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfUserCBExchangeResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfUserCBExchangeResp__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CfUserCBConsumeParam

@implementation CfUserCBConsumeParam

@dynamic token;
@dynamic coin;
@dynamic orderId;

typedef struct CfUserCBConsumeParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  NSString *orderId;
  uint64_t coin;
} CfUserCBConsumeParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = CfUserCBConsumeParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfUserCBConsumeParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "coin",
        .number = CfUserCBConsumeParam_FieldNumber_Coin,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfUserCBConsumeParam__storage_, coin),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "orderId",
        .number = CfUserCBConsumeParam_FieldNumber_OrderId,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfUserCBConsumeParam__storage_, orderId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\003\007\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfUserCBConsumeParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfUserCBConsumeParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CfUserCBConsumeResp

@implementation CfUserCBConsumeResp

@dynamic hasResp, resp;
@dynamic hasHistory, history;

typedef struct CfUserCBConsumeResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  CFCBHistory *history;
} CfUserCBConsumeResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = CfUserCBConsumeResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfUserCBConsumeResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "history",
        .number = CfUserCBConsumeResp_FieldNumber_History,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfUserCBConsumeResp__storage_, history),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CFCBHistory),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfUserCBConsumeResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfUserCBConsumeResp__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateCFUserParam

@implementation UpdateCFUserParam

@dynamic token;
@dynamic hasCfUser, cfUser;

typedef struct UpdateCFUserParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  CfUser *cfUser;
} UpdateCFUserParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = UpdateCFUserParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(UpdateCFUserParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "cfUser",
        .number = UpdateCFUserParam_FieldNumber_CfUser,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(UpdateCFUserParam__storage_, cfUser),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfUser),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\006\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateCFUserParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(UpdateCFUserParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateCFUserResp

@implementation UpdateCFUserResp

@dynamic hasResp, resp;
@dynamic hasCfUser, cfUser;

typedef struct UpdateCFUserResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  CfUser *cfUser;
} UpdateCFUserResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = UpdateCFUserResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(UpdateCFUserResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "cfUser",
        .number = UpdateCFUserResp_FieldNumber_CfUser,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(UpdateCFUserResp__storage_, cfUser),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfUser),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\006\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateCFUserResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(UpdateCFUserResp__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuditCfProjectParam

@implementation AuditCfProjectParam

@dynamic token;
@dynamic projectId;
@dynamic status;

typedef struct AuditCfProjectParam__storage_ {
  uint32_t _has_storage_[1];
  CfProjectStatus status;
  NSString *token;
  int64_t projectId;
} AuditCfProjectParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = AuditCfProjectParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(AuditCfProjectParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "projectId",
        .number = AuditCfProjectParam_FieldNumber_ProjectId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(AuditCfProjectParam__storage_, projectId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "status",
        .number = AuditCfProjectParam_FieldNumber_Status,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(AuditCfProjectParam__storage_, status),
        .defaultValue.valueEnum = CfProjectStatus_InvalidCfps,
        .dataTypeSpecific.enumDescFunc = CfProjectStatus_EnumDescriptor,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\t\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuditCfProjectParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(AuditCfProjectParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AuditCfProjectParam_Status_RawValue(AuditCfProjectParam *message) {
  GPBDescriptor *descriptor = [AuditCfProjectParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuditCfProjectParam_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetAuditCfProjectParam_Status_RawValue(AuditCfProjectParam *message, int32_t value) {
  GPBDescriptor *descriptor = [AuditCfProjectParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AuditCfProjectParam_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UpdateCfProjectParam

@implementation UpdateCfProjectParam

@dynamic token;
@dynamic hasProject, project;

typedef struct UpdateCfProjectParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  CfProject *project;
} UpdateCfProjectParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = UpdateCfProjectParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(UpdateCfProjectParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "project",
        .number = UpdateCfProjectParam_FieldNumber_Project,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(UpdateCfProjectParam__storage_, project),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProject),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateCfProjectParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(UpdateCfProjectParam__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateCfProjectResp

@implementation UpdateCfProjectResp

@dynamic hasResp, resp;
@dynamic hasProject, project;

typedef struct UpdateCfProjectResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  CfProject *project;
} UpdateCfProjectResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = UpdateCfProjectResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(UpdateCfProjectResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "project",
        .number = UpdateCfProjectResp_FieldNumber_Project,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(UpdateCfProjectResp__storage_, project),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProject),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateCfProjectResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(UpdateCfProjectResp__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FindCfUsersParam

@implementation FindCfUsersParam

@dynamic token;
@dynamic role;

typedef struct FindCfUsersParam__storage_ {
  uint32_t _has_storage_[1];
  CfUserRole role;
  NSString *token;
} FindCfUsersParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = FindCfUsersParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(FindCfUsersParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "role",
        .number = FindCfUsersParam_FieldNumber_Role,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(FindCfUsersParam__storage_, role),
        .defaultValue.valueEnum = CfUserRole_InvalidCfur,
        .dataTypeSpecific.enumDescFunc = CfUserRole_EnumDescriptor,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FindCfUsersParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(FindCfUsersParam__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t FindCfUsersParam_Role_RawValue(FindCfUsersParam *message) {
  GPBDescriptor *descriptor = [FindCfUsersParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FindCfUsersParam_FieldNumber_Role];
  return GPBGetMessageInt32Field(message, field);
}

void SetFindCfUsersParam_Role_RawValue(FindCfUsersParam *message, int32_t value) {
  GPBDescriptor *descriptor = [FindCfUsersParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FindCfUsersParam_FieldNumber_Role];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - FindCfUsersResp

@implementation FindCfUsersResp

@dynamic hasResp, resp;
@dynamic usersArray, usersArray_Count;

typedef struct FindCfUsersResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  NSMutableArray *usersArray;
} FindCfUsersResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = FindCfUsersResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(FindCfUsersResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "usersArray",
        .number = FindCfUsersResp_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(FindCfUsersResp__storage_, usersArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfUser),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FindCfUsersResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(FindCfUsersResp__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PassCfUserCertApplyParam

@implementation PassCfUserCertApplyParam

@dynamic token;
@dynamic applyId;

typedef struct PassCfUserCertApplyParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  int64_t applyId;
} PassCfUserCertApplyParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = PassCfUserCertApplyParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(PassCfUserCertApplyParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "applyId",
        .number = PassCfUserCertApplyParam_FieldNumber_ApplyId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(PassCfUserCertApplyParam__storage_, applyId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\007\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PassCfUserCertApplyParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(PassCfUserCertApplyParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RejectCfUserCertApplyParam

@implementation RejectCfUserCertApplyParam

@dynamic token;
@dynamic applyId;
@dynamic comment;

typedef struct RejectCfUserCertApplyParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  NSString *comment;
  int64_t applyId;
} RejectCfUserCertApplyParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = RejectCfUserCertApplyParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(RejectCfUserCertApplyParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "applyId",
        .number = RejectCfUserCertApplyParam_FieldNumber_ApplyId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(RejectCfUserCertApplyParam__storage_, applyId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "comment",
        .number = RejectCfUserCertApplyParam_FieldNumber_Comment,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(RejectCfUserCertApplyParam__storage_, comment),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\007\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RejectCfUserCertApplyParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(RejectCfUserCertApplyParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FindCfUserCertApplyListParam

@implementation FindCfUserCertApplyListParam

@dynamic token;
@dynamic status;
@dynamic type;

typedef struct FindCfUserCertApplyListParam__storage_ {
  uint32_t _has_storage_[1];
  CfUserCeritificationStatus status;
  CfUserCertificationType type;
  NSString *token;
} FindCfUserCertApplyListParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = FindCfUserCertApplyListParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(FindCfUserCertApplyListParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "status",
        .number = FindCfUserCertApplyListParam_FieldNumber_Status,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(FindCfUserCertApplyListParam__storage_, status),
        .defaultValue.valueEnum = CfUserCeritificationStatus_InvalidCfucs,
        .dataTypeSpecific.enumDescFunc = CfUserCeritificationStatus_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "type",
        .number = FindCfUserCertApplyListParam_FieldNumber_Type,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(FindCfUserCertApplyListParam__storage_, type),
        .defaultValue.valueEnum = CfUserCertificationType_InvalidCfuct,
        .dataTypeSpecific.enumDescFunc = CfUserCertificationType_EnumDescriptor,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FindCfUserCertApplyListParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(FindCfUserCertApplyListParam__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t FindCfUserCertApplyListParam_Status_RawValue(FindCfUserCertApplyListParam *message) {
  GPBDescriptor *descriptor = [FindCfUserCertApplyListParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FindCfUserCertApplyListParam_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetFindCfUserCertApplyListParam_Status_RawValue(FindCfUserCertApplyListParam *message, int32_t value) {
  GPBDescriptor *descriptor = [FindCfUserCertApplyListParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FindCfUserCertApplyListParam_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t FindCfUserCertApplyListParam_Type_RawValue(FindCfUserCertApplyListParam *message) {
  GPBDescriptor *descriptor = [FindCfUserCertApplyListParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FindCfUserCertApplyListParam_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetFindCfUserCertApplyListParam_Type_RawValue(FindCfUserCertApplyListParam *message, int32_t value) {
  GPBDescriptor *descriptor = [FindCfUserCertApplyListParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FindCfUserCertApplyListParam_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - FindCfUserCertApplyListResp

@implementation FindCfUserCertApplyListResp

@dynamic hasResp, resp;
@dynamic certsArray, certsArray_Count;

typedef struct FindCfUserCertApplyListResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  NSMutableArray *certsArray;
} FindCfUserCertApplyListResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = FindCfUserCertApplyListResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(FindCfUserCertApplyListResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "certsArray",
        .number = FindCfUserCertApplyListResp_FieldNumber_CertsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(FindCfUserCertApplyListResp__storage_, certsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfUserCertApply),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FindCfUserCertApplyListResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(FindCfUserCertApplyListResp__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetRCCFUserTokenParam

@implementation GetRCCFUserTokenParam

@dynamic token;

typedef struct GetRCCFUserTokenParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} GetRCCFUserTokenParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = GetRCCFUserTokenParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(GetRCCFUserTokenParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRCCFUserTokenParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(GetRCCFUserTokenParam__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetRCCFUserTokenResp

@implementation GetRCCFUserTokenResp

@dynamic hasResp, resp;
@dynamic rcToken;

typedef struct GetRCCFUserTokenResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  NSString *rcToken;
} GetRCCFUserTokenResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = GetRCCFUserTokenResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(GetRCCFUserTokenResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "rcToken",
        .number = GetRCCFUserTokenResp_FieldNumber_RcToken,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(GetRCCFUserTokenResp__storage_, rcToken),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\007\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRCCFUserTokenResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(GetRCCFUserTokenResp__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CloseCfProjectParam

@implementation CloseCfProjectParam

@dynamic token;
@dynamic projectId;

typedef struct CloseCfProjectParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  int64_t projectId;
} CloseCfProjectParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = CloseCfProjectParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CloseCfProjectParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "projectId",
        .number = CloseCfProjectParam_FieldNumber_ProjectId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CloseCfProjectParam__storage_, projectId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\t\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CloseCfProjectParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CloseCfProjectParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CloseCfProjectResp

@implementation CloseCfProjectResp

@dynamic hasResp, resp;
@dynamic hasProject, project;

typedef struct CloseCfProjectResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  CfProject *project;
} CloseCfProjectResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = CloseCfProjectResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CloseCfProjectResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "project",
        .number = CloseCfProjectResp_FieldNumber_Project,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CloseCfProjectResp__storage_, project),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProject),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CloseCfProjectResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CloseCfProjectResp__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetCfProjectParam

@implementation GetCfProjectParam

@dynamic projectId;

typedef struct GetCfProjectParam__storage_ {
  uint32_t _has_storage_[1];
  int64_t projectId;
} GetCfProjectParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "projectId",
        .number = GetCfProjectParam_FieldNumber_ProjectId,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(GetCfProjectParam__storage_, projectId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\001\t\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetCfProjectParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(GetCfProjectParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetCfProjectResp

@implementation GetCfProjectResp

@dynamic hasResp, resp;
@dynamic hasProject, project;

typedef struct GetCfProjectResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  CfProject *project;
} GetCfProjectResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = GetCfProjectResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(GetCfProjectResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "project",
        .number = GetCfProjectResp_FieldNumber_Project,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(GetCfProjectResp__storage_, project),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProject),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetCfProjectResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(GetCfProjectResp__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewCfProjectInvestParam

@implementation NewCfProjectInvestParam

@dynamic token;
@dynamic cfProjectId;
@dynamic cfProjectRewardId;
@dynamic count;
@dynamic comment;
@dynamic addrId;

typedef struct NewCfProjectInvestParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  NSString *comment;
  int64_t cfProjectId;
  int64_t cfProjectRewardId;
  uint64_t count;
  int64_t addrId;
} NewCfProjectInvestParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = NewCfProjectInvestParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(NewCfProjectInvestParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "cfProjectId",
        .number = NewCfProjectInvestParam_FieldNumber_CfProjectId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(NewCfProjectInvestParam__storage_, cfProjectId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "cfProjectRewardId",
        .number = NewCfProjectInvestParam_FieldNumber_CfProjectRewardId,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(NewCfProjectInvestParam__storage_, cfProjectRewardId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "count",
        .number = NewCfProjectInvestParam_FieldNumber_Count,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(NewCfProjectInvestParam__storage_, count),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "comment",
        .number = NewCfProjectInvestParam_FieldNumber_Comment,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(NewCfProjectInvestParam__storage_, comment),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "addrId",
        .number = NewCfProjectInvestParam_FieldNumber_AddrId,
        .hasIndex = 5,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(NewCfProjectInvestParam__storage_, addrId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\003\002\013\000\003\021\000\006\006\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewCfProjectInvestParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(NewCfProjectInvestParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewCfProjectInvestResp

@implementation NewCfProjectInvestResp

@dynamic hasResp, resp;
@dynamic hasInvest, invest;

typedef struct NewCfProjectInvestResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  CfProjectInvest *invest;
} NewCfProjectInvestResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = NewCfProjectInvestResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(NewCfProjectInvestResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "invest",
        .number = NewCfProjectInvestResp_FieldNumber_Invest,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(NewCfProjectInvestResp__storage_, invest),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProjectInvest),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewCfProjectInvestResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(NewCfProjectInvestResp__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelCfUserAddrParam

@implementation DelCfUserAddrParam

@dynamic token;
@dynamic addrId;

typedef struct DelCfUserAddrParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  int64_t addrId;
} DelCfUserAddrParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = DelCfUserAddrParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(DelCfUserAddrParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "addrId",
        .number = DelCfUserAddrParam_FieldNumber_AddrId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(DelCfUserAddrParam__storage_, addrId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\006\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelCfUserAddrParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(DelCfUserAddrParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserUnCollectProjectParam

@implementation UserUnCollectProjectParam

@dynamic token;
@dynamic projectId;

typedef struct UserUnCollectProjectParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  int64_t projectId;
} UserUnCollectProjectParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = UserUnCollectProjectParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(UserUnCollectProjectParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "projectId",
        .number = UserUnCollectProjectParam_FieldNumber_ProjectId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(UserUnCollectProjectParam__storage_, projectId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\t\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserUnCollectProjectParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(UserUnCollectProjectParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserCollectProjectParam

@implementation UserCollectProjectParam

@dynamic token;
@dynamic projectId;

typedef struct UserCollectProjectParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  int64_t projectId;
} UserCollectProjectParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = UserCollectProjectParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(UserCollectProjectParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "projectId",
        .number = UserCollectProjectParam_FieldNumber_ProjectId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(UserCollectProjectParam__storage_, projectId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\t\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserCollectProjectParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(UserCollectProjectParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserCertApplyParam

@implementation UserCertApplyParam

@dynamic token;
@dynamic hasApply, apply;

typedef struct UserCertApplyParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  CfUserCertApply *apply;
} UserCertApplyParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = UserCertApplyParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(UserCertApplyParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "apply",
        .number = UserCertApplyParam_FieldNumber_Apply,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(UserCertApplyParam__storage_, apply),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfUserCertApply),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserCertApplyParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(UserCertApplyParam__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserCertApplyResp

@implementation UserCertApplyResp

@dynamic hasResp, resp;
@dynamic hasApply, apply;

typedef struct UserCertApplyResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  CfUserCertApply *apply;
} UserCertApplyResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = UserCertApplyResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(UserCertApplyResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "apply",
        .number = UserCertApplyResp_FieldNumber_Apply,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(UserCertApplyResp__storage_, apply),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfUserCertApply),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserCertApplyResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(UserCertApplyResp__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RegisterCFAppUserResp

@implementation RegisterCFAppUserResp

@dynamic hasResp, resp;
@dynamic hasCfUser, cfUser;

typedef struct RegisterCFAppUserResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  CfUser *cfUser;
} RegisterCFAppUserResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = RegisterCFAppUserResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(RegisterCFAppUserResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "cfUser",
        .number = RegisterCFAppUserResp_FieldNumber_CfUser,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(RegisterCFAppUserResp__storage_, cfUser),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfUser),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\006\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterCFAppUserResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(RegisterCFAppUserResp__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LoginCFAppResp

@implementation LoginCFAppResp

@dynamic hasResp, resp;
@dynamic hasCfUser, cfUser;
@dynamic token;

typedef struct LoginCFAppResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  CfUser *cfUser;
  NSString *token;
} LoginCFAppResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = LoginCFAppResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(LoginCFAppResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "cfUser",
        .number = LoginCFAppResp_FieldNumber_CfUser,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(LoginCFAppResp__storage_, cfUser),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfUser),
        .fieldOptions = NULL,
      },
      {
        .name = "token",
        .number = LoginCFAppResp_FieldNumber_Token,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(LoginCFAppResp__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\001\002\006\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginCFAppResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(LoginCFAppResp__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RaiseCfProjectParam

@implementation RaiseCfProjectParam

@dynamic token;
@dynamic hasProject, project;

typedef struct RaiseCfProjectParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  CfProject *project;
} RaiseCfProjectParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = RaiseCfProjectParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(RaiseCfProjectParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "project",
        .number = RaiseCfProjectParam_FieldNumber_Project,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(RaiseCfProjectParam__storage_, project),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProject),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RaiseCfProjectParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(RaiseCfProjectParam__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RaiseCfProjectResp

@implementation RaiseCfProjectResp

@dynamic hasResp, resp;
@dynamic hasProject, project;

typedef struct RaiseCfProjectResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  CfProject *project;
} RaiseCfProjectResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = RaiseCfProjectResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(RaiseCfProjectResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "project",
        .number = RaiseCfProjectResp_FieldNumber_Project,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(RaiseCfProjectResp__storage_, project),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProject),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RaiseCfProjectResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(RaiseCfProjectResp__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FindCfProjectsParam

@implementation FindCfProjectsParam

@dynamic category;
@dynamic status;
@dynamic tag;
@dynamic page;
@dynamic size;

typedef struct FindCfProjectsParam__storage_ {
  uint32_t _has_storage_[1];
  CrowdFundingCategory category;
  CfProjectStatus status;
  CfProjectTag tag;
  int64_t page;
  int64_t size;
} FindCfProjectsParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "category",
        .number = FindCfProjectsParam_FieldNumber_Category,
        .hasIndex = 0,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(FindCfProjectsParam__storage_, category),
        .defaultValue.valueEnum = CrowdFundingCategory_InvalidCfc,
        .dataTypeSpecific.enumDescFunc = CrowdFundingCategory_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "status",
        .number = FindCfProjectsParam_FieldNumber_Status,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(FindCfProjectsParam__storage_, status),
        .defaultValue.valueEnum = CfProjectStatus_InvalidCfps,
        .dataTypeSpecific.enumDescFunc = CfProjectStatus_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "tag",
        .number = FindCfProjectsParam_FieldNumber_Tag,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(FindCfProjectsParam__storage_, tag),
        .defaultValue.valueEnum = CfProjectTag_InvalidCfpt,
        .dataTypeSpecific.enumDescFunc = CfProjectTag_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "page",
        .number = FindCfProjectsParam_FieldNumber_Page,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(FindCfProjectsParam__storage_, page),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "size",
        .number = FindCfProjectsParam_FieldNumber_Size,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(FindCfProjectsParam__storage_, size),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FindCfProjectsParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(FindCfProjectsParam__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t FindCfProjectsParam_Category_RawValue(FindCfProjectsParam *message) {
  GPBDescriptor *descriptor = [FindCfProjectsParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FindCfProjectsParam_FieldNumber_Category];
  return GPBGetMessageInt32Field(message, field);
}

void SetFindCfProjectsParam_Category_RawValue(FindCfProjectsParam *message, int32_t value) {
  GPBDescriptor *descriptor = [FindCfProjectsParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FindCfProjectsParam_FieldNumber_Category];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t FindCfProjectsParam_Status_RawValue(FindCfProjectsParam *message) {
  GPBDescriptor *descriptor = [FindCfProjectsParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FindCfProjectsParam_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetFindCfProjectsParam_Status_RawValue(FindCfProjectsParam *message, int32_t value) {
  GPBDescriptor *descriptor = [FindCfProjectsParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FindCfProjectsParam_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t FindCfProjectsParam_Tag_RawValue(FindCfProjectsParam *message) {
  GPBDescriptor *descriptor = [FindCfProjectsParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FindCfProjectsParam_FieldNumber_Tag];
  return GPBGetMessageInt32Field(message, field);
}

void SetFindCfProjectsParam_Tag_RawValue(FindCfProjectsParam *message, int32_t value) {
  GPBDescriptor *descriptor = [FindCfProjectsParam descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FindCfProjectsParam_FieldNumber_Tag];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - FindCfProjectsResp

@implementation FindCfProjectsResp

@dynamic hasResp, resp;
@dynamic projectsArray, projectsArray_Count;

typedef struct FindCfProjectsResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  NSMutableArray *projectsArray;
} FindCfProjectsResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = FindCfProjectsResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(FindCfProjectsResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "projectsArray",
        .number = FindCfProjectsResp_FieldNumber_ProjectsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(FindCfProjectsResp__storage_, projectsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProject),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FindCfProjectsResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(FindCfProjectsResp__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CfUserCertApply

@implementation CfUserCertApply

@dynamic id_p;
@dynamic type;
@dynamic cfUserId;
@dynamic applyTime;
@dynamic status;
@dynamic auditor;
@dynamic comment;
@dynamic auditTime;
@dynamic name;
@dynamic school;
@dynamic picsArray, picsArray_Count;
@dynamic hongId;

typedef struct CfUserCertApply__storage_ {
  uint32_t _has_storage_[1];
  CfUserCertificationType type;
  CfUserCeritificationStatus status;
  NSString *comment;
  NSString *name;
  NSString *school;
  NSMutableArray *picsArray;
  int64_t id_p;
  int64_t cfUserId;
  int64_t applyTime;
  uint64_t auditor;
  int64_t auditTime;
  uint64_t hongId;
} CfUserCertApply__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .number = CfUserCertApply_FieldNumber_Id_p,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfUserCertApply__storage_, id_p),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "type",
        .number = CfUserCertApply_FieldNumber_Type,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CfUserCertApply__storage_, type),
        .defaultValue.valueEnum = CfUserCertificationType_InvalidCfuct,
        .dataTypeSpecific.enumDescFunc = CfUserCertificationType_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "cfUserId",
        .number = CfUserCertApply_FieldNumber_CfUserId,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfUserCertApply__storage_, cfUserId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "applyTime",
        .number = CfUserCertApply_FieldNumber_ApplyTime,
        .hasIndex = 3,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfUserCertApply__storage_, applyTime),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "status",
        .number = CfUserCertApply_FieldNumber_Status,
        .hasIndex = 4,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CfUserCertApply__storage_, status),
        .defaultValue.valueEnum = CfUserCeritificationStatus_InvalidCfucs,
        .dataTypeSpecific.enumDescFunc = CfUserCeritificationStatus_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "auditor",
        .number = CfUserCertApply_FieldNumber_Auditor,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfUserCertApply__storage_, auditor),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "comment",
        .number = CfUserCertApply_FieldNumber_Comment,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfUserCertApply__storage_, comment),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "auditTime",
        .number = CfUserCertApply_FieldNumber_AuditTime,
        .hasIndex = 7,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfUserCertApply__storage_, auditTime),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "name",
        .number = CfUserCertApply_FieldNumber_Name,
        .hasIndex = 8,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfUserCertApply__storage_, name),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "school",
        .number = CfUserCertApply_FieldNumber_School,
        .hasIndex = 9,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfUserCertApply__storage_, school),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "picsArray",
        .number = CfUserCertApply_FieldNumber_PicsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfUserCertApply__storage_, picsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfUserCertPic),
        .fieldOptions = NULL,
      },
      {
        .name = "hongId",
        .number = CfUserCertApply_FieldNumber_HongId,
        .hasIndex = 11,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfUserCertApply__storage_, hongId),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\004\003\010\000\004\t\000\010\t\000\r\006\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfUserCertApply class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfUserCertApply__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CfUserCertApply_Type_RawValue(CfUserCertApply *message) {
  GPBDescriptor *descriptor = [CfUserCertApply descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfUserCertApply_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetCfUserCertApply_Type_RawValue(CfUserCertApply *message, int32_t value) {
  GPBDescriptor *descriptor = [CfUserCertApply descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfUserCertApply_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t CfUserCertApply_Status_RawValue(CfUserCertApply *message) {
  GPBDescriptor *descriptor = [CfUserCertApply descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfUserCertApply_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetCfUserCertApply_Status_RawValue(CfUserCertApply *message, int32_t value) {
  GPBDescriptor *descriptor = [CfUserCertApply descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfUserCertApply_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CfUserCertPic

@implementation CfUserCertPic

@dynamic id_p;
@dynamic cfUserCertApplyId;
@dynamic uRL;

typedef struct CfUserCertPic__storage_ {
  uint32_t _has_storage_[1];
  NSString *uRL;
  int64_t id_p;
  int64_t cfUserCertApplyId;
} CfUserCertPic__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .number = CfUserCertPic_FieldNumber_Id_p,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfUserCertPic__storage_, id_p),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "cfUserCertApplyId",
        .number = CfUserCertPic_FieldNumber_CfUserCertApplyId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfUserCertPic__storage_, cfUserCertApplyId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "uRL",
        .number = CfUserCertPic_FieldNumber_URL,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfUserCertPic__storage_, uRL),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\002\021\000\003\001!!\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfUserCertPic class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfUserCertPic__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CfProjectInvest

@implementation CfProjectInvest

@dynamic id_p;
@dynamic cfProjectId;
@dynamic cfProjectRewardId;
@dynamic count;
@dynamic investTime;
@dynamic hongId;
@dynamic comment;
@dynamic addrId;
@dynamic expiredTime;
@dynamic status;
@dynamic orderId;
@dynamic coinPay;
@dynamic rewardName;
@dynamic projectName;
@dynamic cfUserId;
@dynamic projectPic;
@dynamic rewardCount;
@dynamic rewardAmount;
@dynamic rewardSupportType;
@dynamic investorAvatar;
@dynamic investorNick;

typedef struct CfProjectInvest__storage_ {
  uint32_t _has_storage_[1];
  CfProjectInvestStatus status;
  CfProjectSupportType rewardSupportType;
  NSString *comment;
  NSString *orderId;
  NSString *rewardName;
  NSString *projectName;
  NSString *projectPic;
  NSString *investorAvatar;
  NSString *investorNick;
  int64_t id_p;
  int64_t cfProjectId;
  int64_t cfProjectRewardId;
  uint64_t count;
  int64_t investTime;
  uint64_t hongId;
  int64_t addrId;
  int64_t expiredTime;
  uint64_t coinPay;
  int64_t cfUserId;
  uint64_t rewardCount;
  uint64_t rewardAmount;
} CfProjectInvest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .number = CfProjectInvest_FieldNumber_Id_p,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProjectInvest__storage_, id_p),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "cfProjectId",
        .number = CfProjectInvest_FieldNumber_CfProjectId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProjectInvest__storage_, cfProjectId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "cfProjectRewardId",
        .number = CfProjectInvest_FieldNumber_CfProjectRewardId,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProjectInvest__storage_, cfProjectRewardId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "count",
        .number = CfProjectInvest_FieldNumber_Count,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProjectInvest__storage_, count),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "investTime",
        .number = CfProjectInvest_FieldNumber_InvestTime,
        .hasIndex = 4,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProjectInvest__storage_, investTime),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "hongId",
        .number = CfProjectInvest_FieldNumber_HongId,
        .hasIndex = 5,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProjectInvest__storage_, hongId),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "comment",
        .number = CfProjectInvest_FieldNumber_Comment,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProjectInvest__storage_, comment),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "addrId",
        .number = CfProjectInvest_FieldNumber_AddrId,
        .hasIndex = 7,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProjectInvest__storage_, addrId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "expiredTime",
        .number = CfProjectInvest_FieldNumber_ExpiredTime,
        .hasIndex = 8,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProjectInvest__storage_, expiredTime),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "status",
        .number = CfProjectInvest_FieldNumber_Status,
        .hasIndex = 9,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CfProjectInvest__storage_, status),
        .defaultValue.valueEnum = CfProjectInvestStatus_InvalidCfpis,
        .dataTypeSpecific.enumDescFunc = CfProjectInvestStatus_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "orderId",
        .number = CfProjectInvest_FieldNumber_OrderId,
        .hasIndex = 10,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProjectInvest__storage_, orderId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "coinPay",
        .number = CfProjectInvest_FieldNumber_CoinPay,
        .hasIndex = 11,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProjectInvest__storage_, coinPay),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "rewardName",
        .number = CfProjectInvest_FieldNumber_RewardName,
        .hasIndex = 12,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProjectInvest__storage_, rewardName),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "projectName",
        .number = CfProjectInvest_FieldNumber_ProjectName,
        .hasIndex = 13,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProjectInvest__storage_, projectName),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "cfUserId",
        .number = CfProjectInvest_FieldNumber_CfUserId,
        .hasIndex = 14,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProjectInvest__storage_, cfUserId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "projectPic",
        .number = CfProjectInvest_FieldNumber_ProjectPic,
        .hasIndex = 15,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProjectInvest__storage_, projectPic),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "rewardCount",
        .number = CfProjectInvest_FieldNumber_RewardCount,
        .hasIndex = 16,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProjectInvest__storage_, rewardCount),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "rewardAmount",
        .number = CfProjectInvest_FieldNumber_RewardAmount,
        .hasIndex = 17,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProjectInvest__storage_, rewardAmount),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "rewardSupportType",
        .number = CfProjectInvest_FieldNumber_RewardSupportType,
        .hasIndex = 18,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CfProjectInvest__storage_, rewardSupportType),
        .defaultValue.valueEnum = CfProjectSupportType_InvalidCfpst,
        .dataTypeSpecific.enumDescFunc = CfProjectSupportType_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "investorAvatar",
        .number = CfProjectInvest_FieldNumber_InvestorAvatar,
        .hasIndex = 19,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProjectInvest__storage_, investorAvatar),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "investorNick",
        .number = CfProjectInvest_FieldNumber_InvestorNick,
        .hasIndex = 20,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProjectInvest__storage_, investorNick),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\021\002\013\000\003\021\000\005\n\000\006\006\000\010\006\000\t\013\000\013\007\000\014\007\000\r\n\000\016\013\000\017\010\000\020\n\000\021\013\000\022\014\000\023\021\000\024\016\000\025\014\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfProjectInvest class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfProjectInvest__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CfProjectInvest_Status_RawValue(CfProjectInvest *message) {
  GPBDescriptor *descriptor = [CfProjectInvest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfProjectInvest_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetCfProjectInvest_Status_RawValue(CfProjectInvest *message, int32_t value) {
  GPBDescriptor *descriptor = [CfProjectInvest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfProjectInvest_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t CfProjectInvest_RewardSupportType_RawValue(CfProjectInvest *message) {
  GPBDescriptor *descriptor = [CfProjectInvest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfProjectInvest_FieldNumber_RewardSupportType];
  return GPBGetMessageInt32Field(message, field);
}

void SetCfProjectInvest_RewardSupportType_RawValue(CfProjectInvest *message, int32_t value) {
  GPBDescriptor *descriptor = [CfProjectInvest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfProjectInvest_FieldNumber_RewardSupportType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CFCBHistory

@implementation CFCBHistory

@dynamic id_p;
@dynamic type;
@dynamic coin;
@dynamic remain;
@dynamic time;
@dynamic orderId;
@dynamic hongId;
@dynamic finished;

typedef struct CFCBHistory__storage_ {
  uint32_t _has_storage_[1];
  BOOL finished;
  CFCBHistoryType type;
  NSString *orderId;
  int64_t id_p;
  uint64_t coin;
  uint64_t remain;
  int64_t time;
  uint64_t hongId;
} CFCBHistory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .number = CFCBHistory_FieldNumber_Id_p,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CFCBHistory__storage_, id_p),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "type",
        .number = CFCBHistory_FieldNumber_Type,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CFCBHistory__storage_, type),
        .defaultValue.valueEnum = CFCBHistoryType_InvaildCb,
        .dataTypeSpecific.enumDescFunc = CFCBHistoryType_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "coin",
        .number = CFCBHistory_FieldNumber_Coin,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CFCBHistory__storage_, coin),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "remain",
        .number = CFCBHistory_FieldNumber_Remain,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CFCBHistory__storage_, remain),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "time",
        .number = CFCBHistory_FieldNumber_Time,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CFCBHistory__storage_, time),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "orderId",
        .number = CFCBHistory_FieldNumber_OrderId,
        .hasIndex = 5,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CFCBHistory__storage_, orderId),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "hongId",
        .number = CFCBHistory_FieldNumber_HongId,
        .hasIndex = 6,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CFCBHistory__storage_, hongId),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "finished",
        .number = CFCBHistory_FieldNumber_Finished,
        .hasIndex = 7,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
        .offset = offsetof(CFCBHistory__storage_, finished),
        .defaultValue.valueBool = NO,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\006\007\000\007\006\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CFCBHistory class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CFCBHistory__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CFCBHistory_Type_RawValue(CFCBHistory *message) {
  GPBDescriptor *descriptor = [CFCBHistory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CFCBHistory_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetCFCBHistory_Type_RawValue(CFCBHistory *message, int32_t value) {
  GPBDescriptor *descriptor = [CFCBHistory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CFCBHistory_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CfProjectReward

@implementation CfProjectReward

@dynamic id_p;
@dynamic desc;
@dynamic supportType;
@dynamic amount;
@dynamic limitedCount;
@dynamic cfProjectId;
@dynamic alreadyCount;
@dynamic additionalCoin;
@dynamic del;
@dynamic needAddr;
@dynamic needPhone;

typedef struct CfProjectReward__storage_ {
  uint32_t _has_storage_[1];
  BOOL del;
  BOOL needAddr;
  BOOL needPhone;
  CfProjectSupportType supportType;
  NSString *desc;
  int64_t id_p;
  uint64_t amount;
  uint64_t limitedCount;
  int64_t cfProjectId;
  uint64_t alreadyCount;
  uint64_t additionalCoin;
} CfProjectReward__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .number = CfProjectReward_FieldNumber_Id_p,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProjectReward__storage_, id_p),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "desc",
        .number = CfProjectReward_FieldNumber_Desc,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProjectReward__storage_, desc),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "supportType",
        .number = CfProjectReward_FieldNumber_SupportType,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CfProjectReward__storage_, supportType),
        .defaultValue.valueEnum = CfProjectSupportType_InvalidCfpst,
        .dataTypeSpecific.enumDescFunc = CfProjectSupportType_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "amount",
        .number = CfProjectReward_FieldNumber_Amount,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProjectReward__storage_, amount),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "limitedCount",
        .number = CfProjectReward_FieldNumber_LimitedCount,
        .hasIndex = 4,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProjectReward__storage_, limitedCount),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "cfProjectId",
        .number = CfProjectReward_FieldNumber_CfProjectId,
        .hasIndex = 5,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProjectReward__storage_, cfProjectId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "alreadyCount",
        .number = CfProjectReward_FieldNumber_AlreadyCount,
        .hasIndex = 6,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProjectReward__storage_, alreadyCount),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "additionalCoin",
        .number = CfProjectReward_FieldNumber_AdditionalCoin,
        .hasIndex = 7,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProjectReward__storage_, additionalCoin),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "del",
        .number = CfProjectReward_FieldNumber_Del,
        .hasIndex = 8,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
        .offset = offsetof(CfProjectReward__storage_, del),
        .defaultValue.valueBool = NO,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "needAddr",
        .number = CfProjectReward_FieldNumber_NeedAddr,
        .hasIndex = 9,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
        .offset = offsetof(CfProjectReward__storage_, needAddr),
        .defaultValue.valueBool = NO,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "needPhone",
        .number = CfProjectReward_FieldNumber_NeedPhone,
        .hasIndex = 10,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
        .offset = offsetof(CfProjectReward__storage_, needPhone),
        .defaultValue.valueBool = NO,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\007\003\013\000\005\014\000\006K\000\007\014\000\010\016\000\n\010\000\013\t\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfProjectReward class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfProjectReward__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CfProjectReward_SupportType_RawValue(CfProjectReward *message) {
  GPBDescriptor *descriptor = [CfProjectReward descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfProjectReward_FieldNumber_SupportType];
  return GPBGetMessageInt32Field(message, field);
}

void SetCfProjectReward_SupportType_RawValue(CfProjectReward *message, int32_t value) {
  GPBDescriptor *descriptor = [CfProjectReward descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfProjectReward_FieldNumber_SupportType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UsersCollectProjects

@implementation UsersCollectProjects

@dynamic id_p;
@dynamic cfProjectId;
@dynamic cfUserId;

typedef struct UsersCollectProjects__storage_ {
  uint32_t _has_storage_[1];
  int64_t id_p;
  int64_t cfProjectId;
  int64_t cfUserId;
} UsersCollectProjects__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .number = UsersCollectProjects_FieldNumber_Id_p,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(UsersCollectProjects__storage_, id_p),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "cfProjectId",
        .number = UsersCollectProjects_FieldNumber_CfProjectId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(UsersCollectProjects__storage_, cfProjectId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "cfUserId",
        .number = UsersCollectProjects_FieldNumber_CfUserId,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(UsersCollectProjects__storage_, cfUserId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\002K\000\003H\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UsersCollectProjects class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(UsersCollectProjects__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CfProject

@implementation CfProject

@dynamic id_p;
@dynamic title;
@dynamic desc;
@dynamic contact;
@dynamic tel;
@dynamic cfUserId;
@dynamic fundTime;
@dynamic picsArray, picsArray_Count;
@dynamic requiredMoneyAmount;
@dynamic requiredGoodsAmount;
@dynamic requiredPeopleAmount;
@dynamic requiredGoodsName;
@dynamic deadline;
@dynamic category;
@dynamic rewardsArray, rewardsArray_Count;
@dynamic status;
@dynamic collectedUsersArray, collectedUsersArray_Count;
@dynamic investsArray, investsArray_Count;
@dynamic tag;
@dynamic hongId;
@dynamic auditTime;
@dynamic auditer;
@dynamic alreadyMoneyAmount;
@dynamic alreadyGoodsAmount;
@dynamic alreadyPeopleAmount;
@dynamic majarType;
@dynamic school;
@dynamic requiredProjectAmount;
@dynamic requiredProjectEquity;
@dynamic alreadyProjectEquity;
@dynamic additionalCoin;
@dynamic secondProductEquity;
@dynamic parentProjectId;
@dynamic profitRate;
@dynamic intro;

typedef struct CfProject__storage_ {
  uint32_t _has_storage_[2];
  CrowdFundingCategory category;
  CfProjectStatus status;
  CfProjectTag tag;
  CfProjectSupportType majarType;
  NSString *title;
  NSString *desc;
  NSString *contact;
  NSString *tel;
  NSMutableArray *picsArray;
  NSString *requiredGoodsName;
  NSMutableArray *rewardsArray;
  NSMutableArray *collectedUsersArray;
  NSMutableArray *investsArray;
  NSString *school;
  NSString *intro;
  int64_t id_p;
  int64_t cfUserId;
  int64_t fundTime;
  uint64_t requiredMoneyAmount;
  uint64_t requiredGoodsAmount;
  uint64_t requiredPeopleAmount;
  int64_t deadline;
  uint64_t hongId;
  int64_t auditTime;
  uint64_t auditer;
  uint64_t alreadyMoneyAmount;
  uint64_t alreadyGoodsAmount;
  uint64_t alreadyPeopleAmount;
  uint64_t requiredProjectAmount;
  uint64_t requiredProjectEquity;
  uint64_t alreadyProjectEquity;
  uint64_t additionalCoin;
  uint64_t secondProductEquity;
  int64_t parentProjectId;
  uint64_t profitRate;
} CfProject__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .number = CfProject_FieldNumber_Id_p,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProject__storage_, id_p),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "title",
        .number = CfProject_FieldNumber_Title,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProject__storage_, title),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "desc",
        .number = CfProject_FieldNumber_Desc,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProject__storage_, desc),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "contact",
        .number = CfProject_FieldNumber_Contact,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProject__storage_, contact),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "tel",
        .number = CfProject_FieldNumber_Tel,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProject__storage_, tel),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "cfUserId",
        .number = CfProject_FieldNumber_CfUserId,
        .hasIndex = 5,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProject__storage_, cfUserId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "fundTime",
        .number = CfProject_FieldNumber_FundTime,
        .hasIndex = 6,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProject__storage_, fundTime),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "picsArray",
        .number = CfProject_FieldNumber_PicsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfProject__storage_, picsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProjectPic),
        .fieldOptions = NULL,
      },
      {
        .name = "requiredMoneyAmount",
        .number = CfProject_FieldNumber_RequiredMoneyAmount,
        .hasIndex = 8,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProject__storage_, requiredMoneyAmount),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "requiredGoodsAmount",
        .number = CfProject_FieldNumber_RequiredGoodsAmount,
        .hasIndex = 9,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProject__storage_, requiredGoodsAmount),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "requiredPeopleAmount",
        .number = CfProject_FieldNumber_RequiredPeopleAmount,
        .hasIndex = 10,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProject__storage_, requiredPeopleAmount),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "requiredGoodsName",
        .number = CfProject_FieldNumber_RequiredGoodsName,
        .hasIndex = 11,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProject__storage_, requiredGoodsName),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "deadline",
        .number = CfProject_FieldNumber_Deadline,
        .hasIndex = 12,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProject__storage_, deadline),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "category",
        .number = CfProject_FieldNumber_Category,
        .hasIndex = 13,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CfProject__storage_, category),
        .defaultValue.valueEnum = CrowdFundingCategory_InvalidCfc,
        .dataTypeSpecific.enumDescFunc = CrowdFundingCategory_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "rewardsArray",
        .number = CfProject_FieldNumber_RewardsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfProject__storage_, rewardsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProjectReward),
        .fieldOptions = NULL,
      },
      {
        .name = "status",
        .number = CfProject_FieldNumber_Status,
        .hasIndex = 15,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CfProject__storage_, status),
        .defaultValue.valueEnum = CfProjectStatus_InvalidCfps,
        .dataTypeSpecific.enumDescFunc = CfProjectStatus_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "collectedUsersArray",
        .number = CfProject_FieldNumber_CollectedUsersArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfProject__storage_, collectedUsersArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfUser),
        .fieldOptions = NULL,
      },
      {
        .name = "investsArray",
        .number = CfProject_FieldNumber_InvestsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfProject__storage_, investsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProjectInvest),
        .fieldOptions = NULL,
      },
      {
        .name = "tag",
        .number = CfProject_FieldNumber_Tag,
        .hasIndex = 18,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CfProject__storage_, tag),
        .defaultValue.valueEnum = CfProjectTag_InvalidCfpt,
        .dataTypeSpecific.enumDescFunc = CfProjectTag_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "hongId",
        .number = CfProject_FieldNumber_HongId,
        .hasIndex = 19,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProject__storage_, hongId),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "auditTime",
        .number = CfProject_FieldNumber_AuditTime,
        .hasIndex = 20,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProject__storage_, auditTime),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "auditer",
        .number = CfProject_FieldNumber_Auditer,
        .hasIndex = 21,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProject__storage_, auditer),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "alreadyMoneyAmount",
        .number = CfProject_FieldNumber_AlreadyMoneyAmount,
        .hasIndex = 22,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProject__storage_, alreadyMoneyAmount),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "alreadyGoodsAmount",
        .number = CfProject_FieldNumber_AlreadyGoodsAmount,
        .hasIndex = 23,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProject__storage_, alreadyGoodsAmount),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "alreadyPeopleAmount",
        .number = CfProject_FieldNumber_AlreadyPeopleAmount,
        .hasIndex = 24,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProject__storage_, alreadyPeopleAmount),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "majarType",
        .number = CfProject_FieldNumber_MajarType,
        .hasIndex = 25,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CfProject__storage_, majarType),
        .defaultValue.valueEnum = CfProjectSupportType_InvalidCfpst,
        .dataTypeSpecific.enumDescFunc = CfProjectSupportType_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "school",
        .number = CfProject_FieldNumber_School,
        .hasIndex = 26,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProject__storage_, school),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "requiredProjectAmount",
        .number = CfProject_FieldNumber_RequiredProjectAmount,
        .hasIndex = 27,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProject__storage_, requiredProjectAmount),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "requiredProjectEquity",
        .number = CfProject_FieldNumber_RequiredProjectEquity,
        .hasIndex = 28,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProject__storage_, requiredProjectEquity),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "alreadyProjectEquity",
        .number = CfProject_FieldNumber_AlreadyProjectEquity,
        .hasIndex = 29,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProject__storage_, alreadyProjectEquity),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "additionalCoin",
        .number = CfProject_FieldNumber_AdditionalCoin,
        .hasIndex = 30,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProject__storage_, additionalCoin),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "secondProductEquity",
        .number = CfProject_FieldNumber_SecondProductEquity,
        .hasIndex = 31,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProject__storage_, secondProductEquity),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "parentProjectId",
        .number = CfProject_FieldNumber_ParentProjectId,
        .hasIndex = 32,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProject__storage_, parentProjectId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "profitRate",
        .number = CfProject_FieldNumber_ProfitRate,
        .hasIndex = 33,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProject__storage_, profitRate),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "intro",
        .number = CfProject_FieldNumber_Intro,
        .hasIndex = 34,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProject__storage_, intro),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\024\006\010\000\007\010\000\t\023\000\n\023\000\013\024\000\014\021\000\021\000collectedUsers\000\024\006\000\025\t\000\027\022\000\030\022\000\031\023\000\032\t\000\034\025\000\035\025\000\036\024\000\037\016\000 \023\000!\017\000\"\n\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfProject class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfProject__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CfProject_Category_RawValue(CfProject *message) {
  GPBDescriptor *descriptor = [CfProject descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfProject_FieldNumber_Category];
  return GPBGetMessageInt32Field(message, field);
}

void SetCfProject_Category_RawValue(CfProject *message, int32_t value) {
  GPBDescriptor *descriptor = [CfProject descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfProject_FieldNumber_Category];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t CfProject_Status_RawValue(CfProject *message) {
  GPBDescriptor *descriptor = [CfProject descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfProject_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetCfProject_Status_RawValue(CfProject *message, int32_t value) {
  GPBDescriptor *descriptor = [CfProject descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfProject_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t CfProject_Tag_RawValue(CfProject *message) {
  GPBDescriptor *descriptor = [CfProject descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfProject_FieldNumber_Tag];
  return GPBGetMessageInt32Field(message, field);
}

void SetCfProject_Tag_RawValue(CfProject *message, int32_t value) {
  GPBDescriptor *descriptor = [CfProject descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfProject_FieldNumber_Tag];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t CfProject_MajarType_RawValue(CfProject *message) {
  GPBDescriptor *descriptor = [CfProject descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfProject_FieldNumber_MajarType];
  return GPBGetMessageInt32Field(message, field);
}

void SetCfProject_MajarType_RawValue(CfProject *message, int32_t value) {
  GPBDescriptor *descriptor = [CfProject descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfProject_FieldNumber_MajarType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CfProjectPic

@implementation CfProjectPic

@dynamic id_p;
@dynamic cfProjectId;
@dynamic uRL;
@dynamic del;

typedef struct CfProjectPic__storage_ {
  uint32_t _has_storage_[1];
  BOOL del;
  NSString *uRL;
  int64_t id_p;
  int64_t cfProjectId;
} CfProjectPic__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .number = CfProjectPic_FieldNumber_Id_p,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProjectPic__storage_, id_p),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "cfProjectId",
        .number = CfProjectPic_FieldNumber_CfProjectId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProjectPic__storage_, cfProjectId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "uRL",
        .number = CfProjectPic_FieldNumber_URL,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProjectPic__storage_, uRL),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "del",
        .number = CfProjectPic_FieldNumber_Del,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
        .offset = offsetof(CfProjectPic__storage_, del),
        .defaultValue.valueBool = NO,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\002\013\000\003\001!!\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfProjectPic class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfProjectPic__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CfUser

@implementation CfUser

@dynamic id_p;
@dynamic hongId;
@dynamic fundProjectsArray, fundProjectsArray_Count;
@dynamic hasCertification, certification;
@dynamic collectedProjectsArray, collectedProjectsArray_Count;
@dynamic investProjectsArray, investProjectsArray_Count;
@dynamic point;
@dynamic coin;
@dynamic rcToken;
@dynamic role;
@dynamic hasUser, user;

typedef struct CfUser__storage_ {
  uint32_t _has_storage_[1];
  CfUserRole role;
  NSMutableArray *fundProjectsArray;
  CfUserCertApply *certification;
  NSMutableArray *collectedProjectsArray;
  NSMutableArray *investProjectsArray;
  NSString *rcToken;
  User *user;
  int64_t id_p;
  uint64_t hongId;
  uint64_t point;
  uint64_t coin;
} CfUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .number = CfUser_FieldNumber_Id_p,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfUser__storage_, id_p),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "hongId",
        .number = CfUser_FieldNumber_HongId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfUser__storage_, hongId),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "fundProjectsArray",
        .number = CfUser_FieldNumber_FundProjectsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfUser__storage_, fundProjectsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProject),
        .fieldOptions = NULL,
      },
      {
        .name = "certification",
        .number = CfUser_FieldNumber_Certification,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfUser__storage_, certification),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfUserCertApply),
        .fieldOptions = NULL,
      },
      {
        .name = "collectedProjectsArray",
        .number = CfUser_FieldNumber_CollectedProjectsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfUser__storage_, collectedProjectsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProject),
        .fieldOptions = NULL,
      },
      {
        .name = "investProjectsArray",
        .number = CfUser_FieldNumber_InvestProjectsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfUser__storage_, investProjectsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProjectInvest),
        .fieldOptions = NULL,
      },
      {
        .name = "point",
        .number = CfUser_FieldNumber_Point,
        .hasIndex = 6,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfUser__storage_, point),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "coin",
        .number = CfUser_FieldNumber_Coin,
        .hasIndex = 7,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfUser__storage_, coin),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "rcToken",
        .number = CfUser_FieldNumber_RcToken,
        .hasIndex = 8,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfUser__storage_, rcToken),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "role",
        .number = CfUser_FieldNumber_Role,
        .hasIndex = 9,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CfUser__storage_, role),
        .defaultValue.valueEnum = CfUserRole_InvalidCfur,
        .dataTypeSpecific.enumDescFunc = CfUserRole_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "user",
        .number = CfUser_FieldNumber_User,
        .hasIndex = 10,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfUser__storage_, user),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\005\002\006\000\003\000fundProjects\000\005\000collectedProjects\000\006\000investProjects\000\t\007\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfUser class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfUser__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CfUser_Role_RawValue(CfUser *message) {
  GPBDescriptor *descriptor = [CfUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfUser_FieldNumber_Role];
  return GPBGetMessageInt32Field(message, field);
}

void SetCfUser_Role_RawValue(CfUser *message, int32_t value) {
  GPBDescriptor *descriptor = [CfUser descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfUser_FieldNumber_Role];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CfMessage

@implementation CfMessage

@dynamic title;
@dynamic time;
@dynamic type;
@dynamic content;
@dynamic hasProject, project;
@dynamic hasComment, comment;

typedef struct CfMessage__storage_ {
  uint32_t _has_storage_[1];
  CfMessageType type;
  NSString *title;
  NSString *content;
  CfProject *project;
  CfProjectComment *comment;
  int64_t time;
} CfMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .number = CfMessage_FieldNumber_Title,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfMessage__storage_, title),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "time",
        .number = CfMessage_FieldNumber_Time,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfMessage__storage_, time),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "type",
        .number = CfMessage_FieldNumber_Type,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
        .offset = offsetof(CfMessage__storage_, type),
        .defaultValue.valueEnum = CfMessageType_InvalidCfmt,
        .dataTypeSpecific.enumDescFunc = CfMessageType_EnumDescriptor,
        .fieldOptions = NULL,
      },
      {
        .name = "content",
        .number = CfMessage_FieldNumber_Content,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfMessage__storage_, content),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "project",
        .number = CfMessage_FieldNumber_Project,
        .hasIndex = 4,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfMessage__storage_, project),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProject),
        .fieldOptions = NULL,
      },
      {
        .name = "comment",
        .number = CfMessage_FieldNumber_Comment,
        .hasIndex = 5,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfMessage__storage_, comment),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProjectComment),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfMessage class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfMessage__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CfMessage_Type_RawValue(CfMessage *message) {
  GPBDescriptor *descriptor = [CfMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfMessage_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetCfMessage_Type_RawValue(CfMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [CfMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CfMessage_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CfProjectComment

@implementation CfProjectComment

@dynamic id_p;
@dynamic projectId;
@dynamic avatar;
@dynamic userId;
@dynamic userNick;
@dynamic repliedUserId;
@dynamic repliedUserNick;
@dynamic content;
@dynamic time;

typedef struct CfProjectComment__storage_ {
  uint32_t _has_storage_[1];
  NSString *avatar;
  NSString *userNick;
  NSString *repliedUserNick;
  NSString *content;
  int64_t id_p;
  int64_t projectId;
  uint64_t userId;
  uint64_t repliedUserId;
  int64_t time;
} CfProjectComment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .number = CfProjectComment_FieldNumber_Id_p,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProjectComment__storage_, id_p),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "projectId",
        .number = CfProjectComment_FieldNumber_ProjectId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProjectComment__storage_, projectId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "avatar",
        .number = CfProjectComment_FieldNumber_Avatar,
        .hasIndex = 2,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProjectComment__storage_, avatar),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userId",
        .number = CfProjectComment_FieldNumber_UserId,
        .hasIndex = 3,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProjectComment__storage_, userId),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "userNick",
        .number = CfProjectComment_FieldNumber_UserNick,
        .hasIndex = 4,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProjectComment__storage_, userNick),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "repliedUserId",
        .number = CfProjectComment_FieldNumber_RepliedUserId,
        .hasIndex = 5,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProjectComment__storage_, repliedUserId),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "repliedUserNick",
        .number = CfProjectComment_FieldNumber_RepliedUserNick,
        .hasIndex = 6,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProjectComment__storage_, repliedUserNick),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "content",
        .number = CfProjectComment_FieldNumber_Content,
        .hasIndex = 7,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProjectComment__storage_, content),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "time",
        .number = CfProjectComment_FieldNumber_Time,
        .hasIndex = 8,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProjectComment__storage_, time),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\005\002\t\000\004\006\000\005\010\000\006\r\000\007\017\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfProjectComment class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfProjectComment__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CfProjectCommentParam

@implementation CfProjectCommentParam

@dynamic token;
@dynamic projectId;
@dynamic repliedUserId;
@dynamic content;

typedef struct CfProjectCommentParam__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  NSString *content;
  int64_t projectId;
  uint64_t repliedUserId;
} CfProjectCommentParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .number = CfProjectCommentParam_FieldNumber_Token,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProjectCommentParam__storage_, token),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "projectId",
        .number = CfProjectCommentParam_FieldNumber_ProjectId,
        .hasIndex = 1,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt64,
        .offset = offsetof(CfProjectCommentParam__storage_, projectId),
        .defaultValue.valueInt64 = 0LL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "repliedUserId",
        .number = CfProjectCommentParam_FieldNumber_RepliedUserId,
        .hasIndex = 2,
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeUInt64,
        .offset = offsetof(CfProjectCommentParam__storage_, repliedUserId),
        .defaultValue.valueUInt64 = 0ULL,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
      {
        .name = "content",
        .number = CfProjectCommentParam_FieldNumber_Content,
        .hasIndex = 3,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
        .offset = offsetof(CfProjectCommentParam__storage_, content),
        .defaultValue.valueString = nil,
        .dataTypeSpecific.className = NULL,
        .fieldOptions = NULL,
      },
    };
#if GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    const char *extraTextFormatInfo = NULL;
#else
    static const char *extraTextFormatInfo = "\002\002\t\000\003\r\000";
#endif  // GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfProjectCommentParam class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfProjectCommentParam__storage_)
                                    wireFormat:NO
                           extraTextFormatInfo:extraTextFormatInfo];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CfProjectCommentResp

@implementation CfProjectCommentResp

@dynamic hasResp, resp;
@dynamic hasComment, comment;
@dynamic commentsArray, commentsArray_Count;

typedef struct CfProjectCommentResp__storage_ {
  uint32_t _has_storage_[1];
  Response *resp;
  CfProjectComment *comment;
  NSMutableArray *commentsArray;
} CfProjectCommentResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resp",
        .number = CfProjectCommentResp_FieldNumber_Resp,
        .hasIndex = 0,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfProjectCommentResp__storage_, resp),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .fieldOptions = NULL,
      },
      {
        .name = "comment",
        .number = CfProjectCommentResp_FieldNumber_Comment,
        .hasIndex = 1,
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfProjectCommentResp__storage_, comment),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProjectComment),
        .fieldOptions = NULL,
      },
      {
        .name = "commentsArray",
        .number = CfProjectCommentResp_FieldNumber_CommentsArray,
        .hasIndex = GPBNoHasBit,
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
        .offset = offsetof(CfProjectCommentResp__storage_, commentsArray),
        .defaultValue.valueMessage = nil,
        .dataTypeSpecific.className = GPBStringifySymbol(CfProjectComment),
        .fieldOptions = NULL,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CfProjectCommentResp class]
                                     rootClass:[OutsouringCrowdfundingRoot class]
                                          file:OutsouringCrowdfundingRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:sizeof(fields) / sizeof(GPBMessageFieldDescription)
                                        oneofs:NULL
                                    oneofCount:0
                                         enums:NULL
                                     enumCount:0
                                        ranges:NULL
                                    rangeCount:0
                                   storageSize:sizeof(CfProjectCommentResp__storage_)
                                    wireFormat:NO];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


// @@protoc_insertion_point(global_scope)
